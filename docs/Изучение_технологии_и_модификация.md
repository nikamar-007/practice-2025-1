# Технология 3D рендеринга: реализация и модификации

## Оглавление

1. [Введение](#введение)
2. [Изучение технологии](#изучение-технологии)
3. [Архитектура проекта после рефакторинга](#архитектура-проекта-после-рефакторинга)
4. [Новый алгоритм работы 3D рендерера](#новый-алгоритм-работы-3D-рендерера)
   - [Загрузка модели](#загрузка-модели)
   - [Преобразование координат](#преобразование-координат)
   - [Растеризация треугольников](#растеризация-треугольников)
5. [Функция управления мышью](#функция-управления-мышью)
6. [Примеры моделей](#примеры-моделей)
   - [Куб](#куб)
   - [Призма](#призма-призма)
   - [Стандартная фигура](#стандартная-фигура)
7. [Итоги рефакторинга и улучшений](#итоги-рефакторинга-и-улучшений)
8. [Заключение](#заключение)

---
## Введение

В данной документации рассматривается реализация простого 3D рендерера на Java без использования графических библиотек вроде OpenGL или Java3D, основанного на статье [*"How to create your own simple 3D render engine in pure Java"*](http://blog.rogach.org/2015/08/how-to-create-your-own-simple-3d-render.html).  

В ходе работы над проектом были внесены следующие ключевые изменения:

-  Интерактивное управление 3D-моделью с помощью мыши.
-  Поддержка загрузки пользовательских моделей из текстовых файлов.
-  Рефакторинг кода для улучшения структуры и читаемости.

---

## Изучение технологии
### Ключевые концепции, изученные из статьи:

1. Представление модели через треугольники
   
Модель объекта формируется из треугольников, каждая грань описана тремя вершинами.

- Каждая вершина включает координаты в 3D-пространстве (x, y, z).

- Все треугольники сохраняются в списке и обрабатываются при отрисовке.

---
2. Пространственные преобразования
   
Вращение вокруг осей (`heading`, `pitch`) реализуется с помощью матриц 3×3:

- Ось Y: вращение камеры вокруг вертикали.

- Ось X: наклон камеры вверх/вниз.

Используются базовые формулы поворота:

```java
Matrix3 headingTransform = new Matrix3(new double[]{
    Math.cos(heading), 0, -Math.sin(heading),
    0, 1, 0,
    Math.sin(heading), 0, Math.cos(heading)
});
```

- Все вершины треугольников умножаются на полученную матрицу преобразования.

---
3. Проекция на экран (перспективная проекция)

После преобразований координаты проектируются в 2D, используя соотношение:

![image](https://github.com/user-attachments/assets/0f9bdba2-ad28-4c1f-86fd-535c17dfbd3f)
 
Это имитирует перспективу: дальние объекты кажутся меньше.

Полученные координаты масштабируются и сдвигаются к центру экрана.

---
4. Освещение
   
- Вычисляется нормаль к плоскости треугольника.

- Определяется яркость треугольника на основе угла между нормалью и направлением камеры:

```java
Vertex norm = ab.cross(ac).normalize();
double angleCos = Math.abs(norm.z);
```

Это позволяет затенять треугольники, создавая иллюзию освещённости.

---
5. Отрисовка

Используется `BufferedImage` и метод `setRGB(x, y, color)` для закраски пикселей.

Простой `painter’s algorithm`: треугольники сортируются по глубине (z-среднее) и рисуются от дальних к ближним.

## Архитектура проекта после рефакторинга

Проект состоит из нескольких классов, каждый из которых выполняет свою роль в процессе рендеринга:

| Класс| Назначение|
|-|-|
| `Main`| Точка входа в программу. Запускает `DemoViewer`. |
| `DemoViewer`| Основной класс, отвечающий за отрисовку 3D-сцены и обработку ввода.|
| `Matrix3`| Работа с матрицами 3×3 для преобразования координат.|
| `Vertex`| Описывает вершину в 3D-пространстве и операции с ней.|
| `Triangle`| Хранит три вершины и цвет треугольника.|

---

## Новый алгоритм работы 3D рендерера

### Загрузка модели

Пользователь вводит имя файла (например, `Куб.txt` или `Призма.txt`).

Если файл не найден, загружается стандартная фигура (сфера, созданная методом `getDefaultFigure()`).

**Формат файла:**

```
x1 y1 z1 x2 y2 z2 x3 y3 z3 R G B
```

- `(x1, y1, z1), (x2, y2, z2), (x3, y3, z3)` — координаты вершин треугольника.
- `R G B` — цвет в формате RGB (0–255).

### Преобразование координат

**Вращение (`heading` и `pitch`)** — применяются матрицы поворота:

```java
Matrix3 headingTransform = new Matrix3(new double[]{
    Math.cos(heading), 0, -Math.sin(heading),
    0, 1, 0,
    Math.sin(heading), 0, Math.cos(heading)
});

Matrix3 pitchTransform = new Matrix3(new double[]{
    1, 0, 0,
    0, Math.cos(pitch), Math.sin(pitch),
    0, -Math.sin(pitch), Math.cos(pitch)
});
```

**Итоговая трансформация:**

```java
Matrix3 transform = headingTransform.multiply(pitchTransform);
```

**Масштабирование (`scale`)** — управляется колёсиком мыши:

```java
scale *= 1.1;  // Увеличение
scale /= 1.1;  // Уменьшение
```

**Перемещение (`offsetX`, `offsetY`)** — контролируется правой кнопкой мыши (ПКМ).

### Растеризация треугольников

**Z-буфер (буфер глубины):**

- Массив `zBuffer` хранит глубину каждого пикселя.
- Если новый треугольник ближе к камере, он перекрывает предыдущие.

**Закрашивание треугольников (`fillTriangle`)** — используется барицентрическая интерполяция:

```java
double b1 = ((y - v3.y) * (v2.x - v3.x) + (v2.y - v3.y) * (v3.x - x)) / area;
double b2 = ((y - v1.y) * (v3.x - v1.x) + (v3.y - v1.y) * (v1.x - x)) / area;
double b3 = ((y - v2.y) * (v1.x - v2.x) + (v1.y - v2.y) * (v2.x - x)) / area;
```

Если `b1 >= 0 && b2 >= 0 && b3 >= 0`, точка принадлежит треугольнику.

**Расчёт освещения (`getShade`)** — учитывается угол между нормалью треугольника и направлением камеры:

```java
Vertex norm = ab.cross(ac).normalize();
double angleCos = Math.abs(norm.z);
```

---

## Функция управления мышью

| Действие| Реакция|
|-|-|
| Левая кнопка (ЛКМ) + движение| Вращение модели (`heading`, `pitch`)|
| Правая кнопка (ПКМ) + движение| Перемещение модели (`offsetX`, `offsetY`)|
| Колёсико мыши | Масштабирование (`scale`)|

**Код обработки событий:**

```java
addMouseListener(new MouseAdapter() {
    public void mousePressed(MouseEvent e) {
        if (SwingUtilities.isLeftMouseButton(e)) dragging = true;
        if (SwingUtilities.isRightMouseButton(e)) moving = true;
    }
    public void mouseReleased(MouseEvent e) {
        if (SwingUtilities.isLeftMouseButton(e)) dragging = false;
        if (SwingUtilities.isRightMouseButton(e)) moving = false;
    }
});
```

---

## Примеры моделей

### Куб ([`Куб.txt`](https://github.com/nikamar-007/practice-2025-1/blob/master/src/%D0%9A%D1%83%D0%B1.txt))

```plaintext
-100 -100 -100  100 -100 -100  100  100 -100  255 0 0
-100 -100 -100  100  100 -100  -100  100 -100  255 0 0

-100 -100  100  100 -100  100  100  100  100  0 255 0
-100 -100  100  100  100  100  -100  100  100  0 255 0

-100 -100 -100  -100  100 -100  -100  100  100  0 0 255
-100 -100 -100  -100  100  100  -100 -100  100  0 0 255

100 -100 -100  100  100 -100  100  100  100  255 255 0
100 -100 -100  100  100  100  100 -100  100  255 255 0

-100 -100 -100  -100 -100  100  100 -100  100  0 255 255
-100 -100 -100  100 -100  100  100 -100 -100  0 255 255

-100  100 -100  -100  100  100  100  100  100  255 0 255
-100  100 -100  100  100  100  100  100 -100  255 0 255
```

- Состоит из 12 треугольников (по 2 на каждую грань).
- Каждая грань имеет свой цвет.

### Призма ([`Призма.txt`](https://github.com/nikamar-007/practice-2025-1/blob/master/src/%D0%9F%D1%80%D0%B8%D0%B7%D0%BC%D0%B0.txt))

```plaintext
0 100 0  95.1 100 30.9  58.8 100 80.9  255 255 255
0 100 0  58.8 100 80.9  -58.8 100 80.9  255 255 255
0 100 0  -58.8 100 80.9  -95.1 100 30.9  255 255 255
0 100 0  -95.1 100 30.9  0 100 0  255 255 255
0 100 0  0 100 0  95.1 100 30.9  255 255 255

0 -100 0  95.1 -100 30.9  58.8 -100 80.9  255 0 0
0 -100 0  58.8 -100 80.9  -58.8 -100 80.9  255 0 0
0 -100 0  -58.8 -100 80.9  -95.1 -100 30.9  255 0 0
0 -100 0  -95.1 -100 30.9  0 -100 0  255 0 0
0 -100 0  0 -100 0  95.1 -100 30.9  255 0 0

95.1 100 30.9  95.1 -100 30.9  58.8 -100 80.9  0 255 0
95.1 100 30.9  58.8 -100 80.9  58.8 100 80.9  0 255 0

58.8 100 80.9  58.8 -100 80.9  -58.8 -100 80.9  0 0 255
58.8 100 80.9  -58.8 -100 80.9  -58.8 100 80.9  0 0 255

-58.8 100 80.9  -58.8 -100 80.9  -95.1 -100 30.9  255 255 0
-58.8 100 80.9  -95.1 -100 30.9  -95.1 100 30.9  255 255 0

-95.1 100 30.9  -95.1 -100 30.9  0 -100 0  0 255 255
-95.1 100 30.9  0 -100 0  0 100 0  0 255 255

0 100 0  0 -100 0  95.1 -100 30.9  255 0 255
0 100 0  95.1 -100 30.9  95.1 100 30.9  255 0 255
```

- Более сложная форма с разноцветными гранями.

### Стандартная фигура (Шар)

Если файл не найден, создаётся шар методом `getDefaultFigure()`:

```java
    public static List<Triangle> getDefaultFigure() {
        List<Triangle> tris = new ArrayList();
        ((List)tris).add(new Triangle(new Vertex(100.0, 100.0, 100.0), new Vertex(-100.0, -100.0, 100.0), new Vertex(-100.0, 100.0, -100.0), Color.WHITE));
        ((List)tris).add(new Triangle(new Vertex(100.0, 100.0, 100.0), new Vertex(-100.0, -100.0, 100.0), new Vertex(100.0, -100.0, -100.0), Color.RED));
        ((List)tris).add(new Triangle(new Vertex(-100.0, 100.0, -100.0), new Vertex(100.0, -100.0, -100.0), new Vertex(100.0, 100.0, 100.0), Color.GREEN));
        ((List)tris).add(new Triangle(new Vertex(-100.0, 100.0, -100.0), new Vertex(100.0, -100.0, -100.0), new Vertex(-100.0, -100.0, 100.0), Color.BLUE));

        for(int i = 0; i < 4; ++i) {
            tris = inflate((List)tris);
        }

        return (List)tris;
    }
```

---

## Итоги рефакторинга и улучшений

### Разделение кода (модульность)
**Математическая логика:**

- Классы `Matrix3`, `Vertex` и `Vector3` инкапсулируют операции над векторами, матрицами и координатами.

- Это делает код читабельнее, облегчает тестирование и повторное использование математических компонентов.

**Отделение логики визуализации:**

- Класс `DemoViewer` теперь отвечает только за отображение сцены и взаимодействие с пользователем.

- Модель (`Triangle`, `Model`) и математика отделены, что упрощает внесение изменений.

### Улучшенный ввод-вывод
**Загрузка моделей из файла:**

- Метод `loadTrianglesFromFile(String filename)` позволяет подключать внешние модели в текстовом формате.

- Это расширяет возможности приложения без изменения кода.

**Обработка ошибок:**

- Если файл не найден или содержит ошибки, загружается стандартная модель.

- Пользователь получает уведомление в консоли, приложение продолжает работу без сбоев.

### Оптимизации
**Двойная буферизация:**

- Использование `BufferedImage` позволяет рендерить сцену в памяти перед выводом на экран.

- Это устраняет визуальное мерцание и повышает производительность.

**Эффективный расчёт нормалей и освещения:**

- При рендеринге каждая грань анализируется на основе нормали и положения источника света.

- Используется простая модель освещения, что даёт реалистичную подсветку с минимальными затратами.

### Управление мышью

Расчёт углов поворота осуществляется на основе смещения курсора:

```java
double deltaX = currentX - lastX;
double deltaY = currentY - lastY;
viewer.rotateY(deltaX * sensitivity);
viewer.rotateX(deltaY * sensitivity);
```
**Особенности:**
- Управление мышью является модификацией по сравнению с изначальной реализацией, где управление осуществлялось через клавиатуру.
- Добавление мыши не ломает архитектуру:
  
   - Повороты делегируются в методы вращения (`rotateX`, `rotateY`), работающие с матрицами преобразования.
     
- Это сохраняет чистоту кода и соблюдение принципа единственной ответственности.

**Поведение:**
- Потяните мышь по горизонтали — модель вращается вокруг вертикальной оси.

- Движение по вертикали — поворот вокруг горизонтальной оси.

- Комбинированные движения дают плавное и интерактивное управление сценой.

---

## Заключение

В ходе изучения и реализации технологии 3D-рендеринга на Java был создан функциональный визуализатор, позволяющий загружать и отображать трёхмерные модели с возможностью интерактивного управления. Проект не только воспроизводит базовые принципы 3D-графики — такие как трансформации, освещение, проекцию и растеризацию — но и дополняется рядом усовершенствований:

- Добавлена поддержка загрузки пользовательских моделей из текстовых файлов;

- Реализовано масштабирование, вращение и перемещение сцены с помощью мыши;

- Введена система z-буфера для корректного отображения глубины объектов;

- Оптимизирован и структурирован код с разделением логики по классам.

Данный проект продемонстрировал, как даже без использования графических библиотек высокого уровня можно построить наглядную и управляемую 3D-сцену, опираясь лишь на математические преобразования и принципы компьютерной графики. 

---
#### *Полный комплект кода с примерами файлов можно скачать [здесь](https://github.com/nikamar-007/practice-2025-1/tree/master/src)*

